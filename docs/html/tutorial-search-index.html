<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Implementing a search index | Texturize</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-texturize+doxygen.compiled.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <a href="index.html" id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">Texturize</a>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-dox-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path d="m6 0c-3.3144 0-6 2.6856-6 6 0 3.3144 2.6856 6 6 6 1.4858 0 2.8463-0.54083 3.8945-1.4355-0.0164 0.33797 0.14734 0.75854 0.5 1.1504l3.2227 3.7891c0.55185 0.6139 1.4517 0.66544 2.002 0.11524 0.55022-0.55022 0.49866-1.4501-0.11524-2.002l-3.7891-3.2246c-0.39184-0.35266-0.81242-0.51469-1.1504-0.5 0.89472-1.0482 1.4355-2.4088 1.4355-3.8945 0-3.3128-2.6856-5.998-6-5.998zm0 1.5625a4.4375 4.4375 0 0 1 4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375-4.4375 4.4375 4.4375 0 0 1 4.4375-4.4375z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li>
              <a href="getting-started.html">Getting started</a>
              <ol>
                <li><a href="getting-started-build.html">Creating the project using CMake</a></li>
                <li><a href="getting-started-sandbox.html">Using the Sandbox application</a></li>
              </ol>
            </li>
            <li>
              <a href="tutorial.html">Tutorials</a>
              <ol>
                <li><a href="tutorial-filter.html">Implementing custom filters</a></li>
                <li><a href="tutorial-search-space.html">Creating a search space</a></li>
                <li><a href="tutorial-search-index.html" id="m-navbar-current">Implementing a search index</a></li>
                <li><a href="tutorial-synthesizer.html">Writing your own synthesizer</a></li>
              </ol>
            </li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="3">
            <li><a href="modules.html">Modules</a></li>
            <li><a href="annotated.html">Classes</a></li>
            <li><a href="namespaces.html">Namespaces</a></li>
            <li class="m-show-m"><a href="#search" class="m-dox-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <path d="m6 0c-3.3144 0-6 2.6856-6 6 0 3.3144 2.6856 6 6 6 1.4858 0 2.8463-0.54083 3.8945-1.4355-0.0164 0.33797 0.14734 0.75854 0.5 1.1504l3.2227 3.7891c0.55185 0.6139 1.4517 0.66544 2.002 0.11524 0.55022-0.55022 0.49866-1.4501-0.11524-2.002l-3.7891-3.2246c-0.39184-0.35266-0.81242-0.51469-1.1504-0.5 0.89472-1.0482 1.4355-2.4088 1.4355-3.8945 0-3.3128-2.6856-5.998-6-5.998zm0 1.5625a4.4375 4.4375 0 0 1 4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375-4.4375 4.4375 4.4375 0 0 1 4.4375-4.4375z"/>
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          Implementing a search index
        </h1>
<p>This example demonstrates how to implement a search index. The implementation matches pixel neighborhoods by calculating the euclidean distance between pixel neighborhood descriptors. This basically resembles the naive sampling algorithm, described by Efros and Leung. It is simple to implement, but comes with a certain runtime cost. The <code>init</code> method, thus indexes pixel neighborhoods by using dimensionality reduction to minimize the number of descriptor components. The <code><a href="class_texturize_1_1_descriptor_extractor.html" class="m-dox">Texturize::<wbr />DescriptorExtractor</a></code> base class uses Principal Component Analysis (PCA) for this. Other approaches could use Local Linear Embedding (LLE) or Isomaps. Note that this dimensionality reduction was not done in naive sampling.</p><p>The search index is also responsible for matching pixel neighborhoods during runtime. In this example, each pixel neighborhood of the exemplar is compared against the requested descriptor. This corresponds to an overall cost of <svg class="m-math" style="width: 5.291em; height: 1.245em; vertical-align: -0.312em;" viewBox="0 -8.96638 50.7931 11.9552">
<title>
$ \mathcal{O} (n \times m) $
</title>
<defs>
<path d='M4.65056 -3.32354L2.25953 -5.70262C2.11606 -5.84608 2.09215 -5.86999 1.99651 -5.86999C1.87696 -5.86999 1.75741 -5.76239 1.75741 -5.63088C1.75741 -5.5472 1.78132 -5.52329 1.91283 -5.39178L4.30386 -2.98879L1.91283 -0.585803C1.78132 -0.454296 1.75741 -0.430386 1.75741 -0.3467C1.75741 -0.215193 1.87696 -0.107597 1.99651 -0.107597C2.09215 -0.107597 2.11606 -0.131507 2.25953 -0.274969L4.63861 -2.65405L7.11333 -0.179328C7.13724 -0.167372 7.22092 -0.107597 7.29265 -0.107597C7.43611 -0.107597 7.53176 -0.215193 7.53176 -0.3467C7.53176 -0.37061 7.53176 -0.418431 7.49589 -0.478207C7.48394 -0.502117 5.58306 -2.37908 4.98531 -2.98879L7.1731 -5.17659C7.23288 -5.24832 7.4122 -5.40374 7.47198 -5.47547C7.48394 -5.49938 7.53176 -5.5472 7.53176 -5.63088C7.53176 -5.76239 7.43611 -5.86999 7.29265 -5.86999C7.19701 -5.86999 7.14919 -5.82217 7.01768 -5.69066L4.65056 -3.32354Z' id='eq1-g0-2'/>
<path d='M9.28917 -5.76239C9.28917 -7.2807 8.61968 -8.42839 7.16115 -8.42839C5.91781 -8.42839 4.86575 -7.42416 4.78207 -7.35243C3.82565 -6.40797 3.467 -5.332 3.467 -5.30809C3.467 -5.23636 3.52677 -5.22441 3.58655 -5.22441C3.8137 -5.22441 4.00498 -5.34396 4.18431 -5.47547C4.3995 -5.63088 4.41146 -5.66675 4.54296 -5.94172C4.65056 -6.18082 4.92553 -6.76663 5.36787 -7.26874C5.65479 -7.59153 5.8939 -7.77086 6.3721 -7.77086C7.53176 -7.77086 8.27298 -6.81445 8.27298 -5.24832C8.27298 -2.80946 6.53948 -0.394521 4.32777 -0.394521C2.63014 -0.394521 1.69763 -1.74545 1.69763 -3.45504C1.69763 -5.08095 2.5345 -6.87422 4.27995 -7.90237C4.3995 -7.9741 4.75816 -8.18929 4.75816 -8.34471C4.75816 -8.42839 4.66252 -8.42839 4.63861 -8.42839C4.22017 -8.42839 0.681445 -6.52752 0.681445 -2.94097C0.681445 -1.26725 1.55417 0.263014 3.53873 0.263014C5.86999 0.263014 9.28917 -2.0802 9.28917 -5.76239Z' id='eq1-g0-79'/>
<path d='M3.88543 2.90511C3.88543 2.86924 3.88543 2.84533 3.68219 2.64209C2.48667 1.43462 1.81719 -0.537983 1.81719 -2.97684C1.81719 -5.29614 2.37908 -7.29265 3.76588 -8.70336C3.88543 -8.81096 3.88543 -8.83487 3.88543 -8.87073C3.88543 -8.94247 3.82565 -8.96638 3.77783 -8.96638C3.62242 -8.96638 2.64209 -8.1056 2.05629 -6.934C1.44658 -5.72653 1.17161 -4.44732 1.17161 -2.97684C1.17161 -1.91283 1.33898 -0.490162 1.96065 0.789041C2.666 2.22366 3.64633 3.00075 3.77783 3.00075C3.82565 3.00075 3.88543 2.97684 3.88543 2.90511Z' id='eq1-g2-40'/>
<path d='M3.37136 -2.97684C3.37136 -3.88543 3.25181 -5.36787 2.58232 -6.75467C1.87696 -8.18929 0.896638 -8.96638 0.765131 -8.96638C0.71731 -8.96638 0.657534 -8.94247 0.657534 -8.87073C0.657534 -8.83487 0.657534 -8.81096 0.860772 -8.60772C2.05629 -7.40025 2.72578 -5.42765 2.72578 -2.98879C2.72578 -0.669489 2.16389 1.32702 0.777086 2.73773C0.657534 2.84533 0.657534 2.86924 0.657534 2.90511C0.657534 2.97684 0.71731 3.00075 0.765131 3.00075C0.920548 3.00075 1.90087 2.13998 2.48667 0.968369C3.09639 -0.251059 3.37136 -1.54222 3.37136 -2.97684Z' id='eq1-g2-41'/>
<path d='M2.46276 -3.50286C2.48667 -3.5746 2.78555 -4.17235 3.2279 -4.55492C3.53873 -4.84184 3.94521 -5.03313 4.41146 -5.03313C4.88966 -5.03313 5.05704 -4.67447 5.05704 -4.19626C5.05704 -4.12453 5.05704 -3.88543 4.91357 -3.32354L4.61469 -2.09215C4.51905 -1.7335 4.29191 -0.848817 4.268 -0.71731C4.22017 -0.537983 4.14844 -0.227148 4.14844 -0.179328C4.14844 -0.0119552 4.27995 0.119552 4.45928 0.119552C4.81793 0.119552 4.87771 -0.155417 4.98531 -0.585803L5.70262 -3.44309C5.72653 -3.53873 6.34819 -5.03313 7.66326 -5.03313C8.14147 -5.03313 8.30884 -4.67447 8.30884 -4.19626C8.30884 -3.52677 7.84259 -2.22366 7.57958 -1.50635C7.47198 -1.21943 7.4122 -1.06401 7.4122 -0.848817C7.4122 -0.310834 7.78281 0.119552 8.35666 0.119552C9.46849 0.119552 9.88692 -1.63786 9.88692 -1.70959C9.88692 -1.76936 9.8391 -1.81719 9.76737 -1.81719C9.65978 -1.81719 9.64782 -1.78132 9.58804 -1.57808C9.31308 -0.621669 8.87073 -0.119552 8.39253 -0.119552C8.27298 -0.119552 8.08169 -0.131507 8.08169 -0.514072C8.08169 -0.824907 8.22516 -1.20747 8.27298 -1.33898C8.48817 -1.91283 9.02615 -3.32354 9.02615 -4.01694C9.02615 -4.73425 8.60772 -5.27223 7.69913 -5.27223C6.89813 -5.27223 6.25255 -4.81793 5.77435 -4.11258C5.73848 -4.75816 5.34396 -5.27223 4.44732 -5.27223C3.38331 -5.27223 2.82142 -4.51905 2.60623 -4.22017C2.57036 -4.90162 2.0802 -5.27223 1.55417 -5.27223C1.20747 -5.27223 0.932503 -5.10486 0.705355 -4.65056C0.490162 -4.22017 0.32279 -3.49091 0.32279 -3.44309S0.37061 -3.33549 0.454296 -3.33549C0.549938 -3.33549 0.561893 -3.34745 0.633624 -3.62242C0.812951 -4.32777 1.0401 -5.03313 1.51831 -5.03313C1.79328 -5.03313 1.88892 -4.84184 1.88892 -4.48319C1.88892 -4.22017 1.76936 -3.75392 1.68568 -3.38331L1.35093 -2.09215C1.30311 -1.86501 1.17161 -1.32702 1.11183 -1.11183C1.02814 -0.800996 0.896638 -0.239103 0.896638 -0.179328C0.896638 -0.0119552 1.02814 0.119552 1.20747 0.119552C1.35093 0.119552 1.51831 0.0478207 1.61395 -0.131507C1.63786 -0.191283 1.74545 -0.609714 1.80523 -0.848817L2.06824 -1.92478L2.46276 -3.50286Z' id='eq1-g1-109'/>
<path d='M2.46276 -3.50286C2.48667 -3.5746 2.78555 -4.17235 3.2279 -4.55492C3.53873 -4.84184 3.94521 -5.03313 4.41146 -5.03313C4.88966 -5.03313 5.05704 -4.67447 5.05704 -4.19626C5.05704 -3.51482 4.56687 -2.15193 4.32777 -1.50635C4.22017 -1.21943 4.1604 -1.06401 4.1604 -0.848817C4.1604 -0.310834 4.53101 0.119552 5.10486 0.119552C6.21669 0.119552 6.63512 -1.63786 6.63512 -1.70959C6.63512 -1.76936 6.5873 -1.81719 6.51557 -1.81719C6.40797 -1.81719 6.39601 -1.78132 6.33624 -1.57808C6.06127 -0.597758 5.60697 -0.119552 5.14072 -0.119552C5.02117 -0.119552 4.82989 -0.131507 4.82989 -0.514072C4.82989 -0.812951 4.96139 -1.17161 5.03313 -1.33898C5.27223 -1.99651 5.77435 -3.33549 5.77435 -4.01694C5.77435 -4.73425 5.35592 -5.27223 4.44732 -5.27223C3.38331 -5.27223 2.82142 -4.51905 2.60623 -4.22017C2.57036 -4.90162 2.0802 -5.27223 1.55417 -5.27223C1.17161 -5.27223 0.908593 -5.04508 0.705355 -4.63861C0.490162 -4.20822 0.32279 -3.49091 0.32279 -3.44309S0.37061 -3.33549 0.454296 -3.33549C0.549938 -3.33549 0.561893 -3.34745 0.633624 -3.62242C0.824907 -4.35168 1.0401 -5.03313 1.51831 -5.03313C1.79328 -5.03313 1.88892 -4.84184 1.88892 -4.48319C1.88892 -4.22017 1.76936 -3.75392 1.68568 -3.38331L1.35093 -2.09215C1.30311 -1.86501 1.17161 -1.32702 1.11183 -1.11183C1.02814 -0.800996 0.896638 -0.239103 0.896638 -0.179328C0.896638 -0.0119552 1.02814 0.119552 1.20747 0.119552C1.35093 0.119552 1.51831 0.0478207 1.61395 -0.131507C1.63786 -0.191283 1.74545 -0.609714 1.80523 -0.848817L2.06824 -1.92478L2.46276 -3.50286Z' id='eq1-g1-110'/>
</defs>
<g id='eq1-page1'>
<use x='0' xlink:href='#eq1-g0-79' y='0'/>
<use x='9.84977' xlink:href='#eq1-g2-40' y='0'/>
<use x='14.4021' xlink:href='#eq1-g1-110' y='0'/>
<use x='24.0464' xlink:href='#eq1-g0-2' y='0'/>
<use x='36.0015' xlink:href='#eq1-g1-109' y='0'/>
<use x='46.2408' xlink:href='#eq1-g2-41' y='0'/>
</g>
</svg>, which is not ideal. More satisfied approaches may use quantized search trees or coherencies. The <code><a href="class_texturize_1_1_coherent_index.html" class="m-dox">Texturize::<wbr />CoherentIndex</a></code> uses a pre-calculated set of coherent pixel candidates, from which a random selection is chosen.</p><aside class="m-note m-default"><h4>See also</h4><p>Alexei A. Efros and Thomas K. Leung. &quot;Texture Synthesis by Non Parametric Sampling.&quot; In: Proceedings of the International Conference on Computer Vision - Volume 2. ICCV &#x27;99. Washington, DC, USA: IEEE Computer Society, 1999. isbn: 0-7695-0164-8. url: <a href="http://dl.acm.org/citation.cfm?id=850924.851569">http:/<wbr />/<wbr />dl.acm.org/<wbr />citation.cfm?id=850924.851569</a>.</p><p>Li-Yi Wei and Marc Levoy. &quot;Fast Texture Synthesis Using Tree-structured Vector Quantization.&quot; In: Proceedings of the 27th Annual Conference on Computer Graphics and Interactive Techniques. SIGGRAPH &#x27;00. New York, NY, USA: ACM Press/Addison-Wesley Publishing Co., 2000, pp. 479-488. isbn: 1-58113-208-5. doi: 10.1145/344779.345009. url: <a href="http://dx.doi.org/10.1145/344779.345009">http:/<wbr />/<wbr />dx.doi.org/<wbr />10.1145/<wbr />344779.345009</a>.</p><p>Michael Ashikhmin. &quot;Synthesizing Natural Textures.&quot; In: Proceedings of the 2001 Symposium on Interactive 3D Graphics. I3D &#x27;01. New York, NY, USA: ACM, 2001, pp. 217-226. isbn: 1-58113-292-1. doi: 10.1145/364338.364405. url: <a href="http://doi.acm.org/10.1145/364338.364405">http:/<wbr />/<wbr />doi.acm.org/<wbr />10.1145/<wbr />364338.364405</a>.</p><p>Xin Tong et al. &quot;Synthesis of Bidirectional Texture Functionson Arbitrary Surfaces.&quot; In: ACM Trans. Graph. 21.3 (July 2002), pp. 665-672. issn: 07300301. doi: 10.1145/566654.566634. url: <a href="http://doi.acm.org/10.1145/566654.566634">http:/<wbr />/<wbr />doi.acm.org/<wbr />10.1145/<wbr />566654.566634</a>.</p></aside><pre class="m-code"><span class="cp">#include</span> <span class="cpf">&lt;sampling.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">Texturize</span><span class="p">;</span>

<span class="c1">// ------------------------------------------------------------------------------------------------</span>
<span class="c1">// </span>
<span class="c1">// The example demonstrates how to implement a trivial search index, that matches pixel </span>
<span class="c1">// neighborhoods by comparing their pixel values.</span>
<span class="c1">// </span>
<span class="c1">// ------------------------------------------------------------------------------------------------</span>

<span class="k">class</span> <span class="err">TrivialSearchIndex : public SearchIndex {</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">cv</span><span class="o">::</span><span class="kt">Mat</span> <span class="n">_exemplarDescriptors</span><span class="p">;</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">NormTypes</span> <span class="n">_normType</span><span class="p">;</span>

    <span class="c1">// Constructor</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">TrivialSearchIndex</span><span class="p">(</span><span class="k">const</span> <span class="kt">ISearchSpace</span><span class="o">*</span> <span class="n">searchSpace</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">NormTypes</span> <span class="n">distanceMeasure</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">NORM_L2SQR</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
    <span class="k">void</span> <span class="n">init</span><span class="p">();</span>

    <span class="c1">// ISearchIndex interface</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">bool</span> <span class="n">findNearestNeighbor</span><span class="p">(</span><span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="kt">Mat</span><span class="o">&amp;</span> <span class="n">descriptors</span><span class="p">,</span> <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="kt">Mat</span><span class="o">&amp;</span> <span class="n">uv</span><span class="p">,</span> <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="kt">Point2i</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="kt">Vec2f</span><span class="o">&amp;</span> <span class="n">match</span><span class="p">,</span> <span class="k">float</span> <span class="n">minDist</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="k">float</span><span class="o">*</span> <span class="n">dist</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
    <span class="k">bool</span> <span class="nf">findNearestNeighbors</span><span class="p">(</span><span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="kt">Mat</span><span class="o">&amp;</span> <span class="n">descriptors</span><span class="p">,</span> <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="kt">Mat</span><span class="o">&amp;</span> <span class="n">uv</span><span class="p">,</span> <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="kt">Point2i</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="kt">Vec2f</span><span class="o">&gt;&amp;</span> <span class="n">matches</span><span class="p">,</span> <span class="k">const</span> <span class="k">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="k">float</span> <span class="n">minDist</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">vector</span><span class="o">&lt;</span><span class="k">float</span><span class="o">&gt;*</span> <span class="n">dist</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// ------------------------------------------------------------------------------------------------</span>
<span class="c1">// </span>
<span class="c1">// Construction</span>
<span class="c1">// </span>
<span class="c1">// ------------------------------------------------------------------------------------------------</span>

<span class="n">TrivialSearchIndex</span><span class="o">::</span><span class="n">TrivialSearchIndex</span><span class="p">(</span><span class="k">const</span> <span class="kt">ISearchSpace</span><span class="o">*</span> <span class="n">searchSpace</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">NormTypes</span> <span class="n">distanceMeasure</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">NORM_L2SQR</span><span class="p">)</span> <span class="o">:</span>
    <span class="kt">SearchIndex</span><span class="p">(</span><span class="n">searchSpace</span><span class="p">),</span> <span class="n">_normType</span><span class="p">(</span><span class="n">distanceMeasure</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">void</span> <span class="n">TrivialSearchIndex</span><span class="o">::</span><span class="n">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Precompute the neighborhood descriptors used to train data.</span>
    <span class="k">const</span> <span class="kt">Sample</span><span class="o">*</span> <span class="n">sample</span><span class="p">;</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">getSearchSpace</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">sample</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sample</span><span class="p">);</span>

    <span class="c1">// Form a descriptor vector from the sample.</span>
    <span class="n">_exemplarDescriptors</span> <span class="o">=</span> <span class="kt">DescriptorExtractor</span><span class="o">::</span><span class="n">indexNeighborhoods</span><span class="p">(</span><span class="o">*</span><span class="n">sample</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ------------------------------------------------------------------------------------------------</span>
<span class="c1">// </span>
<span class="c1">// ISearchIndex interface</span>
<span class="c1">// </span>
<span class="c1">// ------------------------------------------------------------------------------------------------</span>

<span class="k">bool</span> <span class="n">TrivialSearchIndex</span><span class="o">::</span><span class="n">findNearestNeighbor</span><span class="p">(</span><span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="kt">Mat</span><span class="o">&amp;</span> <span class="n">descriptors</span><span class="p">,</span> <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="kt">Mat</span><span class="o">&amp;</span> <span class="n">uv</span><span class="p">,</span> <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="kt">Point2i</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="kt">Vec2f</span><span class="o">&amp;</span> <span class="n">match</span><span class="p">,</span> <span class="k">float</span> <span class="n">minDist</span><span class="p">,</span> <span class="k">float</span><span class="o">*</span> <span class="n">dist</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="c1">// This method handles the special case of the k nearest neighbor search, where k equals 1.</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="kt">Vec2f</span><span class="o">&gt;</span> <span class="n">coordinates</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">vector</span><span class="o">&lt;</span><span class="k">float</span><span class="o">&gt;</span> <span class="n">distances</span><span class="p">;</span>
    
    <span class="k">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">findNearestNeighbors</span><span class="p">(</span><span class="n">descriptors</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">at</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">minDist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">distances</span><span class="p">);</span>

    <span class="c1">// In case the search was successfull, return the result.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
            <span class="o">*</span><span class="n">dist</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// The descriptors are a set of pre-calculated neighborhood descriptors, that are passed by the</span>
<span class="c1">// synthesizer, which calculates them from the current sample for each synthesis pass. The uv </span>
<span class="c1">// parameter contains the uv map for the current sample.</span>
<span class="k">bool</span> <span class="n">TrivialSearchIndex</span><span class="o">::</span><span class="n">findNearestNeighbors</span><span class="p">(</span><span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="kt">Mat</span><span class="o">&amp;</span> <span class="n">descriptors</span><span class="p">,</span> <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="kt">Mat</span><span class="o">&amp;</span> <span class="n">uv</span><span class="p">,</span> <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="kt">Point2i</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="kt">Vec2f</span><span class="o">&gt;&amp;</span> <span class="n">matches</span><span class="p">,</span> <span class="k">const</span> <span class="k">int</span> <span class="n">k</span><span class="p">,</span> <span class="k">float</span> <span class="n">minDist</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">vector</span><span class="o">&lt;</span><span class="k">float</span><span class="o">&gt;*</span> <span class="n">dist</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="c1">// Results are handled by putting them into a priority queue, where the similarity represents</span>
    <span class="c1">// the priority. A smaller similarity value equals a higher priority. The queue has a capacity</span>
    <span class="c1">// of k, i.e. only the k most similar candidates are kept within the queue, whilst the others</span>
    <span class="c1">// will be discarded. To do this, the following trait is used to provide the comparison logic </span>
    <span class="c1">// between candidates.</span>
    <span class="c1">// </span>
    <span class="c1">// Note, that a priority queue is not the most efficient way of solving this problem, since the</span>
    <span class="c1">// loop needs to perform many inefficient pops. It is, however, a straightforward and simple</span>
    <span class="c1">// to follow approach.</span>
    <span class="k">struct</span> <span class="n">TakeMoreSimilarCandidate</span> <span class="p">{</span>
        <span class="k">bool</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">TMatch</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">TMatch</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">TMatch</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">vector</span><span class="o">&lt;</span><span class="n">TMatch</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">TakeMoreSimilarCandidate</span><span class="o">&gt;</span> <span class="n">candidates</span><span class="p">();</span>

    <span class="c1">// Get the target descriptor in order to calculate the similarity later on. A descriptor matrix</span>
    <span class="c1">// contains in each row a descriptor. Each column contains a descriptor value. The matrix </span>
    <span class="c1">// itself is a flat array of vectors, that contains as many rows, as there are sample pixels.</span>
    <span class="c1">// The target descriptor matrix thus contains as many rows, as there are pixels in the uv map,</span>
    <span class="c1">// while the exemplar _exemplarDescriptors matrix, contains as many rows as there are exemplar </span>
    <span class="c1">// pixels. The descriptor row can thus be calculated from y * width + x.</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">vector</span><span class="o">&lt;</span><span class="k">float</span><span class="o">&gt;</span> <span class="n">targetDescriptor</span> <span class="o">=</span> <span class="n">descriptors</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">at</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">uv</span><span class="p">.</span><span class="n">cols</span> <span class="o">+</span> <span class="n">at</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
    
    <span class="c1">// Get the search space transformed exemplar and some of its properties.</span>
    <span class="k">const</span> <span class="kt">Sample</span><span class="o">*</span> <span class="n">exemplar</span><span class="p">;</span>
    <span class="k">int</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">;</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">getSearchSpace</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">sample</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exemplar</span><span class="p">);</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">getSearchSpace</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">kernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">);</span>
    <span class="n">width</span> <span class="o">=</span> <span class="n">exemplar</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">();</span>
    <span class="n">height</span> <span class="o">=</span> <span class="n">exemplar</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">();</span>

    <span class="c1">// Compare each exemplar pixel to the descriptor.</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="o">++</span><span class="n">x</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">y</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="o">++</span><span class="n">y</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Get the distance between the exemplar pixel and the currently checked pixel. In case its</span>
        <span class="c1">// is too small, skip the pixel. This increases visual variety by forcing candidates to not</span>
        <span class="c1">// be direct neighbors of the original pixel.</span>
        <span class="n">cv</span><span class="o">::</span><span class="kt">Vec2f</span> <span class="n">originalPos</span> <span class="o">=</span> <span class="n">uv</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="kt">Vec2f</span><span class="o">&gt;</span><span class="p">(</span><span class="n">at</span><span class="p">);</span>
        <span class="n">cv</span><span class="o">::</span><span class="kt">Vec2f</span> <span class="n">candidatePos</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="kt">Vec2f</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">width</span><span class="p">),</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">height</span><span class="p">));</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">norm</span><span class="p">(</span><span class="n">originalPos</span> <span class="o">-</span> <span class="n">candidatePos</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">minDist</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span>

        <span class="c1">// Get the exemplar neighborhood and calculate its similarity to the target descriptor.</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">vector</span><span class="o">&lt;</span><span class="k">float</span><span class="o">&gt;</span> <span class="n">exemplarNeighborhood</span> <span class="o">=</span> <span class="n">_exemplarDescriptors</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">x</span><span class="p">);</span>
        <span class="k">float</span> <span class="n">similarity</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">norm</span><span class="p">(</span><span class="n">targetDescriptor</span><span class="p">,</span> <span class="n">exemplarDescriptor</span><span class="p">,</span> <span class="n">_normType</span><span class="p">);</span>

        <span class="c1">// Store the current candidate.</span>
        <span class="n">TMatch</span> <span class="nf">candidate</span><span class="p">(</span><span class="n">candidatePos</span><span class="p">,</span> <span class="n">similarity</span><span class="p">);</span>
        <span class="n">candidates</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">candidate</span><span class="p">);</span>

        <span class="c1">// Discard the most dissimilar candidate.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">candidates</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">)</span>
            <span class="n">candidates</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// Return the best candidate matches.</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">candidates</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">TMatch</span> <span class="n">candidate</span> <span class="o">=</span> <span class="n">candidates</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">matches</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">candidate</span><span class="p">));</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dist</span><span class="p">)</span>
            <span class="n">dist</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">candidate</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="c1">// If no matches have been found, return false. Here, this only corresponds to the case, where</span>
    <span class="c1">// minDist is set too large and excludes all candidates.</span>
    <span class="k">return</span> <span class="o">!</span><span class="n">matches</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
<span class="p">}</span></pre>
      </div>
    </div>
  </div>
</article></main>
<div class="m-dox-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-dox-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-dox-search-content">
          <input type="search" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" />
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            Search for symbols, directories, files, pages or modules. You can omit any
            prefix from the symbol or file path; adding a <code>:</code> or <code>/</code>
            suffix lists all members of given symbol or directory. Navigate through the
            list using <span class="m-label m-dim">&darr;</span> and
            <span class="m-label m-dim">&uarr;</span>, press
            <span class="m-label m-dim">Enter</span> to go.
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search.js"></script>
<script src="searchdata.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Texturize. Created by <a href="https://doxygen.org/">Doxygen</a> 1.8.14 and <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>