<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Getting started | Texturize</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-texturize+doxygen.compiled.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <a href="index.html" id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">Texturize</a>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-dox-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path d="m6 0c-3.3144 0-6 2.6856-6 6 0 3.3144 2.6856 6 6 6 1.4858 0 2.8463-0.54083 3.8945-1.4355-0.0164 0.33797 0.14734 0.75854 0.5 1.1504l3.2227 3.7891c0.55185 0.6139 1.4517 0.66544 2.002 0.11524 0.55022-0.55022 0.49866-1.4501-0.11524-2.002l-3.7891-3.2246c-0.39184-0.35266-0.81242-0.51469-1.1504-0.5 0.89472-1.0482 1.4355-2.4088 1.4355-3.8945 0-3.3128-2.6856-5.998-6-5.998zm0 1.5625a4.4375 4.4375 0 0 1 4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375-4.4375 4.4375 4.4375 0 0 1 4.4375-4.4375z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li>
              <a href="getting-started.html" id="m-navbar-current">Getting started</a>
              <ol>
                <li><a href="getting-started-build.html">Creating the project using CMake</a></li>
                <li><a href="getting-started-sandbox.html">Using the Sandbox application</a></li>
              </ol>
            </li>
            <li>
              <a href="tutorial.html">Tutorials</a>
              <ol>
                <li><a href="tutorial-filter.html">Implementing custom filters</a></li>
                <li><a href="tutorial-search-space.html">Creating a search space</a></li>
                <li><a href="tutorial-search-index.html">Implementing a search index</a></li>
                <li><a href="tutorial-synthesizer.html">Writing your own synthesizer</a></li>
              </ol>
            </li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="3">
            <li><a href="modules.html">Modules</a></li>
            <li><a href="annotated.html">Classes</a></li>
            <li><a href="namespaces.html">Namespaces</a></li>
            <li class="m-show-m"><a href="#search" class="m-dox-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <path d="m6 0c-3.3144 0-6 2.6856-6 6 0 3.3144 2.6856 6 6 6 1.4858 0 2.8463-0.54083 3.8945-1.4355-0.0164 0.33797 0.14734 0.75854 0.5 1.1504l3.2227 3.7891c0.55185 0.6139 1.4517 0.66544 2.002 0.11524 0.55022-0.55022 0.49866-1.4501-0.11524-2.002l-3.7891-3.2246c-0.39184-0.35266-0.81242-0.51469-1.1504-0.5 0.89472-1.0482 1.4355-2.4088 1.4355-3.8945 0-3.3128-2.6856-5.998-6-5.998zm0 1.5625a4.4375 4.4375 0 0 1 4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375-4.4375 4.4375 4.4375 0 0 1 4.4375-4.4375z"/>
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          Getting started
        </h1>
<p>The following guide will show you how to setup and use the framework to build a simple synthesizer using the provided implementations. The guide shows you how to implement a search space and use it to feed a synthesizer. It will familiarize you with the general workflow of the framework.</p><p>The guide assumes you are familiar with Visual Studio and basic C++ programming. The framework has been built using Visual Studio 2017, so it is recommended to use it too.</p><section id="getting-started-setup"><h2><a href="#getting-started-setup">Setting up your project</a></h2><p>Before you start writing actual code, you need to setup your project. If you haven&#x27;t done it yet, create a new project for your application. Next, you have to tell the compiler where to find the <em><a href="namespace_texturize.html" class="m-dox">Texturize</a></em> library. Therefor, add the <code>include</code> and and <code>lib</code> directories to your project directories. You can do this by right-clicking it in Visual Studio and choosing <code>Properties</code>. Under <code>VC++ Directories</code> add the <code>include</code> directory to the additional include directories and the <code>lib</code> directory to the additional library directories. Next, go to <code>Linker</code> and <code>Input</code> and add the following libraries to additional dependencies.</p><pre class="m-code"><span class="n">Texturize</span><span class="p">.</span><span class="n">Sampling</span><span class="p">.</span><span class="n">lib</span><span class="p">;</span><span class="n">Texturize</span><span class="p">.</span><span class="n">Analysis</span><span class="p">.</span><span class="n">lib</span><span class="p">;</span><span class="n">Texturize</span><span class="p">.</span><span class="n">Core</span><span class="p">.</span><span class="n">lib</span><span class="p">;</span><span class="n">Texturize</span><span class="p">.</span><span class="n">Codecs</span><span class="p">.</span><span class="n">lib</span><span class="p">;</span><span class="n">Texturize</span><span class="p">.</span><span class="n">Codecs</span><span class="p">.</span><span class="n">EXR</span><span class="p">.</span><span class="n">lib</span><span class="p">;</span><span class="o">%</span><span class="p">(</span><span class="n">AdditionalDependencies</span><span class="p">)</span></pre><p>Last but not least, we need to make sure that the framework binaries are copied to your application directory after a build. For this you can add the following post-build event:</p><pre class="m-code"><span class="n">xcopy</span> <span class="o">/</span><span class="n">y</span> <span class="o">/</span><span class="n">d</span>  <span class="s">&quot;&lt;framework directory&gt;\lib\$(PlatformTarget)\$(Configuration)\*.dll&quot;</span> <span class="s">&quot;$(OutDir)&quot;</span></pre><section id="getting-started-setup-manual"><h3><a href="#getting-started-setup-manual">Using a property sheet</a></h3><p>Alternatively to the manual approach above you add the property sheet <code>Texturize.props</code> from the framework directory to your project properties. To do this, open the Property Manager in Visual Studio and right click your project and choose &quot;Add existing
property sheet...&quot;. Select the <code>Texturize.props</code> file and you should be ready to go.</p></section><section id="getting-started-setup-opencv"><h3><a href="#getting-started-setup-opencv">Using OpenCV and other dependencies</a></h3><aside class="m-note m-info"><h4>Note</h4><p>You do not require OpenCV for this guide, but you might need it later. You can skip this section now and come back later, when you require other libraries, if you want so.</p></aside><p>The framework is build upon <a href="https://opencv.org/">OpenCV</a>. If you want to use its types, you have to also include the libraries of OpenCV. This is not done within the property sheet, but instead you can add the following code to the <code>stdafx.cpp</code> file of your project:</p><pre class="m-code"><span class="cp">#ifdef _DEBUG</span>
<span class="cp">#pragma comment(lib, &quot;opencv_core343d.lib&quot;)</span>
<span class="cp">#pragma comment(lib, &quot;opencv_imgproc343d.lib&quot;)</span>
<span class="cp">#pragma comment(lib, &quot;opencv_ximgproc343d.lib&quot;)</span>
<span class="cp">#pragma comment(lib, &quot;opencv_highgui343d.lib&quot;)</span>
<span class="cp">#pragma comment(lib, &quot;opencv_imgcodecs343d.lib&quot;)</span>
<span class="cp">#else</span>
<span class="cp">#pragma comment(lib, &quot;opencv_core343.lib&quot;)</span>
<span class="cp">#pragma comment(lib, &quot;opencv_imgproc343.lib&quot;)</span>
<span class="cp">#pragma comment(lib, &quot;opencv_ximgproc343.lib&quot;)</span>
<span class="cp">#pragma comment(lib, &quot;opencv_highgui343.lib&quot;)</span>
<span class="cp">#pragma comment(lib, &quot;opencv_imgcodecs343.lib&quot;)</span>
<span class="cp">#endif</span></pre><p>Of course you can select which OpenCV libraries you want to use. Other dependencies are <a href="https://hdfgroup.org/">hdf5</a>, <a href="http://www.openexr.com/">OpenEXR</a>, <a href="https://zlib.net/">zlib</a> and <a href="https://www.threadingbuildingblocks.org/">tbb</a>.</p></section></section><section id="getting-started-workflow"><h2><a href="#getting-started-workflow">Implementing synthesis workflow</a></h2><p>Now let&#x27;s finally go into some code. The following headers contain the definitions of <em><a href="namespace_texturize.html" class="m-dox">Texturize</a></em> types, so make sure to include to your projects main source file.</p><pre class="m-code"><span class="cp">#include</span> <span class="cpf">&lt;texturize.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;analysis.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sampling.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;codecs.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;Codecs\exr.hpp&gt;</span><span class="cp"></span></pre><section id="getting-started-workflow-analysis"><h3><a href="#getting-started-workflow-analysis">Analysing exemplars</a></h3><p>In the framework workflow the term <em>Image Analysis</em> describes the process of performing one-time calculations on an exemplar to create a search space with high information density. More simply speaking, you want to look over your images and find characteristics that best describe it. The result is then stored as an asset, which is later used to repeatedly lookup the exemplar efficiently.</p><p>A good example of such an offline pre-process is finding edges, since they describe a texture&#x27;s global structure pretty well, especially for near-regular exemplars.</p><aside class="m-note m-info"><h4>Note</h4><p>Texture regularity plays an important role in judging, how well a texture is suited to be synthesized. Regularity is a spectrum to classify textures in. It is, however, not complete and still an open field of research. Simply speaking, there are five continuous classes of textures: Stochastic, Near-Stochastic, Irregular, Near-Regular, Regular. Those classes are fluent, which means, no texture is fully quantizable into those classes. Instead they belong to a class somewhere between perfectly stochastic and perfectly regular. Stochastic textures are ones, where no complete features can be made out. Good examples are stars, sand or skin. Regular textures on the other hand feature identical, regularly repeating features like for example checkerboards or wallpapers. If you want to read more about regularity, take a look at my thesis <a href="https://github.com/Aschratt/Texturize-Thesis">thesis</a>, where I also link some papers about it.</p></aside><p>However, before we can start analysing images, we have to load them. Persistence is handled in detail more later on, for now, just add a <code>DefaultPersistence</code> instance to your code and you are ready to load images as shown in the following code:</p><pre class="m-code"><span class="cp">#include</span> <span class="cpf">&quot;stdafx.h&quot;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;texturize.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;analysis.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sampling.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;codecs.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;Codecs\exr.hpp&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">Texturize</span><span class="p">;</span>

<span class="n">DefaultPersistence</span> <span class="n">_persistence</span><span class="p">;</span>

<span class="k">int</span> <span class="nf">main</span><span class="p">(</span><span class="k">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="k">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Get command line arguments.</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">string</span> <span class="n">exemplarName</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

    <span class="c1">// Load the sample.</span>
    <span class="kt">Sample</span> <span class="n">exemplar</span><span class="p">;</span>
    <span class="n">_persistence</span><span class="p">.</span><span class="n">loadSample</span><span class="p">(</span><span class="n">exemplarName</span><span class="p">,</span> <span class="n">exemplar</span><span class="p">);</span>

    <span class="c1">// Make sure it has three channels (RGB).</span>
    <span class="n">TEXTURIZE_ASSERT</span><span class="p">(</span><span class="n">exemplar</span><span class="p">.</span><span class="n">channels</span><span class="p">()</span> <span class="o">==</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span></pre><p>Next we can create an edge detector and apply it to our sample.</p><pre class="m-code"><span class="c1">// Get the model name from the second command line argument.</span>
<span class="n">std</span><span class="o">::</span><span class="kt">string</span> <span class="n">edgeDetectorModel</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="n">std</span><span class="o">::</span><span class="kt">unique_ptr</span><span class="o">&lt;</span><span class="n">EdgeDetector</span><span class="o">&gt;</span> <span class="n">detector</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">StructuredEdgeDetector</span><span class="o">&gt;</span><span class="p">(</span><span class="n">edgeDetectorModel</span><span class="p">);</span>

<span class="c1">// Extract the edges.</span>
<span class="kt">Sample</span> <span class="n">edgeResponse</span><span class="p">;</span>
<span class="n">detector</span><span class="o">-&gt;</span><span class="n">apply</span><span class="p">(</span><span class="n">edgeResponse</span><span class="p">,</span> <span class="n">exemplar</span><span class="p">);</span></pre><p>In your command line, you have to provide the location of your exemplar and an edge detector model. The <code><a href="class_texturize_1_1_structured_edge_detector.html" class="m-dox">StructuredEdgeDetector</a></code> implements an edge detector, based on <em>random decision forests</em>. It requires a model to work on. <em><a href="namespace_texturize.html" class="m-dox">Texturize</a></em> provides a model under <code>./models/forest/modelFinal.yml</code>.</p><aside class="m-note m-info"><h4>Note</h4><p>The model has been trained by <a href="http://w-x.ch/publications/self-tuning-texture-optimization/">Kaspar et al</a>.</p></aside><section id="getting-started-workflow-analysis-search-space"><h4><a href="#getting-started-workflow-analysis-search-space">Creating a search space</a></h4><p>The synthesizer of this tutorial works by repeatedly performing a search for the best fitting pixel for a neighborhood. It does this by comparing the target pixel neighborhood to neighborhoods of the exemplar and then stores the coordinate of it to the target pixel&#x27;s position in the result. To do this, it needs to be able to compare pixels by their neighborhoods. A neighborhood can be described by simply putting all neighbor pixels into a large vector of pixel color values. For each pixel, the value of the earlier generated edge map is attached in what is called a <em>guidance channel</em>. In total, a neighborhood therefore generates a vector with 81 dimensions, four channels per pixel of a 3x3 pixel neighborhood. Calculating the difference distance between two vectors in such a high-dimensional space is neither efficient, nor meaningful. The framework therefore implements an <code><a href="class_texturize_1_1_appearance_space.html" class="m-dox">AppearanceSpace</a></code>, which applies Principal Component Analysis (PCA) to the vectors beforehand in order to reduce their dimensionality to 4.</p><p>The following code shows how to mix the exemplar with the edge response to create an appearance space.</p><pre class="m-code"><span class="c1">// Create an appearance space with an dimensionality of 4.</span>
<span class="kt">AppearanceSpace</span><span class="o">*</span> <span class="n">searchSpace</span><span class="p">;</span>
<span class="kt">AppearanceSpace</span><span class="o">::</span><span class="n">calculate</span><span class="p">({</span> <span class="n">exemplar</span><span class="p">,</span> <span class="n">edgeResponse</span> <span class="p">},</span> <span class="o">&amp;</span><span class="n">searchSpace</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

<span class="c1">// It is recommended to use smart pointers to manage search space references.</span>
<span class="n">std</span><span class="o">::</span><span class="kt">unique_ptr</span><span class="o">&lt;</span><span class="kt">AppearanceSpace</span><span class="o">&gt;</span> <span class="n">descriptors</span><span class="p">(</span><span class="n">searchSpace</span><span class="p">);</span>

<span class="c1">// Transform the exemplar into the search space.</span>
<span class="kt">Sample</span> <span class="n">transformedExemplar</span><span class="p">;</span>
<span class="n">descriptors</span><span class="o">-&gt;</span><span class="n">sample</span><span class="p">(</span><span class="n">transformedExemplar</span><span class="p">);</span></pre></section><section id="getting-started-workflow-analysis-persistence"><h4><a href="#getting-started-workflow-analysis-persistence">Storing analysis results</a></h4><p>The search space is what can be stored into an <em>asset</em> in order to re-use it multiple times later on. Since assets can have more pixel descriptors with more than four channels, there is a special asset format implemented to persist them. To use it, a <code><a href="class_texturize_1_1_storage_factory.html" class="m-dox">StorageFactory</a></code> must be created. This factory can be used to implement different asset formats, but for now the default implementation is used. It&#x27;s based on the <em>hdf5</em> standard and stores meta-information about the search space along the transformed exemplar.</p><pre class="m-code"><span class="c1">// Create an asset and store it.</span>
<span class="kt">StorageFactory</span> <span class="n">_storage</span><span class="p">;</span>
<span class="kt">AppearanceSpaceAsset</span> <span class="n">asset</span><span class="p">;</span>

<span class="n">asset</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;myasset.txa&quot;</span><span class="p">,</span> <span class="n">descriptor</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">_storage</span><span class="p">);</span></pre></section></section><section id="getting-started-workflow-search-index"><h3><a href="#getting-started-workflow-search-index">Indexing pixel neighborhoods</a></h3><p>The synthesis code can basically be put in a different application, so you have an image analysis application and can write multiple synthesizer programms with different implementations. The first thing to do for a synthesizer is to load and index the search space. An <code><a href="class_texturize_1_1_search_index.html" class="m-dox">SearchIndex</a></code> is used for neighborhood matching. Runtime neighborhoods are provided to it in order to search for best matches inside the exemplar.</p><p>The following code snippet implements a search index, that uses pixel coherencies to reduce neighborhood search performance. You can find more about its inner workings in the <code><a href="class_texturize_1_1_random_walk_index.html" class="m-dox">RandomWalkIndex</a></code> documentation.</p><pre class="m-code"><span class="cp">#include</span> <span class="cpf">&quot;stdafx.h&quot;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;texturize.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;analysis.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sampling.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;codecs.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;Codecs\exr.hpp&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">Texturize</span><span class="p">;</span>

<span class="n">SamplePersistence</span> <span class="n">_persistence</span><span class="p">;</span>
<span class="kt">StorageFactory</span> <span class="n">_storage</span><span class="p">;</span>

<span class="k">int</span> <span class="nf">main</span><span class="p">(</span><span class="k">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="k">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Restore the asset.</span>
    <span class="kt">AppearanceSpaceAsset</span> <span class="n">asset</span><span class="p">;</span>
    <span class="kt">AppearanceSpace</span><span class="o">*</span> <span class="n">desc</span><span class="p">;</span>
    <span class="n">asset</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="s">&quot;myasset.txa&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span> <span class="n">_storage</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">unique_ptr</span><span class="o">&lt;</span><span class="kt">AppearanceSpace</span><span class="o">&gt;</span> <span class="n">descriptor</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">AppearanceSpace</span><span class="o">&gt;</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>

    <span class="c1">// Index the search space.</span>
    <span class="kt">RandomWalkIndex</span> <span class="n">index</span><span class="p">(</span><span class="n">descriptor</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>    
<span class="p">}</span></pre></section><section id="getting-started-workflow-synthesizer"><h3><a href="#getting-started-workflow-synthesizer">Synthesizing textures</a></h3><p>The final step is to let a synthesizer use the search index to synthesize new textures from it. In this tutorial, we use a parallel synthesizer, that synthesizes textures in 2 sizes by growing an image pyramid. The <code><a href="class_texturize_1_1_parallel_pyramid_synthesizer.html" class="m-dox">ParallelPyramidSynthesizer</a></code> is based on the <em>appearance space synthesizer</em>, described by <a href="http://doi.acm.org/10.1145/1141911.1141921">Sylvain Lefebvre and Hugues Hoppe</a>.</p><pre class="m-code"><span class="c1">// Use the index to create a synthesizer.</span>
<span class="k">auto</span> <span class="n">synthesizer</span> <span class="o">=</span> <span class="kt">ParallelPyramidSynthesizer</span><span class="o">::</span><span class="n">createSynthesizer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">index</span><span class="p">);</span>

<span class="c1">// Get the exemplar and the kernel.</span>
<span class="kt">Sample</span> <span class="n">exemplar</span><span class="p">;</span>
<span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">sample</span><span class="p">(</span><span class="n">kernel</span><span class="p">);</span>
<span class="k">int</span> <span class="n">kernel</span><span class="p">;</span>
<span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">getKernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">);</span>

<span class="c1">// Configure the synthesizer with a constant randomness of 0.1 and the kernel.</span>
<span class="n">PyramidSynthesisSettings</span> <span class="nf">config</span><span class="p">(</span><span class="n">exemplar</span><span class="p">.</span><span class="n">width</span><span class="p">(),</span> <span class="mf">0.1f</span><span class="p">,</span> <span class="n">kernel</span><span class="p">);</span>

<span class="c1">// The progress is printed to the console.</span>
<span class="n">config</span><span class="p">.</span><span class="n">_progressHandler</span><span class="p">.</span><span class="n">add</span><span class="p">([</span><span class="n">depth</span><span class="p">](</span><span class="k">int</span> <span class="n">level</span><span class="p">,</span> <span class="k">int</span> <span class="n">pass</span><span class="p">,</span> <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="kt">Mat</span><span class="o">&amp;</span> <span class="n">uv</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pass</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Executed level &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;/&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">depth</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; (Correction pass skipped)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Executed level &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;/&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">depth</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; (Correction pass &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">pass</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">// Start synthesis.</span>
<span class="kt">Sample</span> <span class="n">resultUv</span><span class="p">;</span>
<span class="n">synthesizer</span><span class="o">-&gt;</span><span class="n">synthesize</span><span class="p">(</span><span class="n">exemplar</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">resultUv</span><span class="p">,</span> <span class="n">config</span><span class="p">);</span></pre><p>The synthesizer creates a new texture with two channels, which is called <em>UV Map</em>. It contains for each pixel, the x and y coordinates of the exemplar pixel. To render a new texture from it, it needs to be sampled, as shown in the following snippet.</p><pre class="m-code"><span class="c1">// Sample the uv map.</span>
<span class="kt">Sample</span> <span class="n">result</span><span class="p">;</span>
<span class="n">exemplar</span><span class="p">.</span><span class="n">sample</span><span class="p">(</span><span class="n">resultUv</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

<span class="c1">// Store the texture.</span>
<span class="n">_persistence</span><span class="p">.</span><span class="n">saveSample</span><span class="p">(</span><span class="s">&quot;result.png&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span></pre></section></section><section id="getting-started-next"><h2><a href="#getting-started-next">Next steps</a></h2><p>Now that you familiarized yourself with the general workflow of the framework, you can start customizing it. There are different tutorials available to help you designing and implementing modules. You can find them under <a href="tutorial.html" class="m-dox">Tutorials</a>.</p><p>If you just want to play around with the default implementations, there is a sandbox application. You can learn more about it under <a href="getting-started-sandbox.html" class="m-dox">Using the Sandbox application</a>.</p></section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-dox-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-dox-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-dox-search-content">
          <input type="search" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" />
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            Search for symbols, directories, files, pages or modules. You can omit any
            prefix from the symbol or file path; adding a <code>:</code> or <code>/</code>
            suffix lists all members of given symbol or directory. Navigate through the
            list using <span class="m-label m-dim">&darr;</span> and
            <span class="m-label m-dim">&uarr;</span>, press
            <span class="m-label m-dim">Enter</span> to go.
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search.js"></script>
<script src="searchdata.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Texturize. Created by <a href="http://doxygen.org/">Doxygen</a> 1.8.13 and <a href="http://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>